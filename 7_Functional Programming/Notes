63.1 Функциональное программирование


    Функциональное программирование - это стиль программирования, который (как следует из названия) основан на функциях.
    Ключевой частью функционального программирования являются функции более высокого порядка. Мы кратко рассмотрели эту идею в предыдущем уроке о функциях как объектах. Функции более высокого порядка принимают другие функции в качестве аргументов или возвращают их в качестве результатов.
    Пример:

    def apply_twice(func, arg):
    return func(func(arg))

    def add_five(x):
        return x + 5

    print(apply_twice(add_five, 10))

    >>20

    Функция apply_twice принимает другую функцию в качестве своего аргумента и дважды вызывает ее внутри своего тела.


Чистые функции

    Функциональное программирование стремится использовать чистые функции. Чистые функции не имеют побочных эффектов и возвращают значение, которое зависит только от их аргументов.
    Вот как работают функции в математике: например, cos(x) при одном и том же значении x всегда возвращает один и тот же результат.
    Ниже приведены примеры чистых и нечистых функций.

    Чистая функция:

    def pure_function(x, y):
        temp = x + 2*y
        return temp / (2*x + y)

    НеЧистая Функция:

    some_list = []
    def impure(arg):
      some_list.append(arg)
   Приведенная выше функция не является чистой, потому что она изменила состояние some_list.

    Использование чистых функций имеет как преимущества, так и недостатки.
    Чистые функции - это:
    - легче анализировать и тестировать.
    - более эффективно. Как только функция была оценена для ввода, результат может быть сохранен и передан в следующий раз, когда потребуется функция этого ввода, что сокращает количество вызовов функции. Это называется запоминанием.
    - легче работать параллельно.

    Основным недостатком использования только чистых функций является то, что они значительно усложняют простую в остальном задачу ввода-вывода, поскольку это, по-видимому, неизбежно требует побочных эффектов.
    В некоторых ситуациях их также может быть сложнее написать.

64.1 Lambdas(лямбда-функции)

    При обычном создании функции (с использованием def) она автоматически присваивается переменной.
    Это отличается от создания других объектов, таких как строки и целые числа, которые можно создавать "на лету", не присваивая их переменной.
    То же самое возможно с функциями, при условии, что они созданы с использованием лямбда-синтаксиса. Функции, созданные таким образом, известны как анонимные.
    Этот подход чаще всего используется при передаче простой функции в качестве аргумента другой функции. Синтаксис показан в следующем примере и состоит из ключевого слова lambda, за которым следует список аргументов, двоеточие и выражение для вычисления и возврата.

    def my_func(f, arg):
      return f(arg)

    my_func(lambda x: 2*x*x, 5)

    Лямбда-функции не так мощны, как именованные функции.
    Они могут выполнять только те действия, которые требуют одного выражения - обычно эквивалентного одной строке кода.

    #named function
    def polynomial(x):
        return x**2 + 5*x + 4
    print(polynomial(-4))

    #lambda
    print((lambda x: x**2 + 5*x + 4) (-4))
    В приведенном выше коде мы создали анонимную функцию "на лету" и вызвали ее с аргументом.

    Лямбда-функции могут быть назначены переменным и использоваться как обычные функции.
    Пример:
    double = lambda x: x * 2
    print(double(7))
    >>14

    Однако для этого редко бывает веская причина - обычно вместо этого лучше определить функцию с помощью def.

65.1 map and filter

    Встроенные функции map и filter - это очень полезные функции более высокого порядка, которые работают со списками (или подобными объектами, называемыми iterables).
    Отображение функций принимает функцию и итерируемый объект в качестве аргументов и возвращает новый итерируемый объект с функцией, примененной к каждому аргументу.
    Пример:

    def add_five(x):
    return x + 5

    nums = [11, 22, 33, 44, 55]
    result = list(map(add_five, nums))
    print(result)

    >>[16, 27, 38, 49, 60]

    Мы могли бы легче достичь того же результата, используя лямбда-синтаксис.

    nums = [11, 22, 33, 44, 55]
    result = list(map(lambda x: x+5, nums))
    print(result)
    >>[16, 27, 38, 49, 60]
    Чтобы преобразовать результат в список, мы явно использовали list.

    Фильтр
    Функция filter фильтрует итерацию, удаляя элементы, которые не соответствуют предикату (функция, возвращающая логическое значение).
    Пример:
    nums = [11, 22, 33, 44, 55]
    res = list(filter(lambda x: x%2==0, nums))
    print(res)
    Как и карта, результат должен быть явно преобразован в список, если вы хотите его распечатать.

66.1 Generators

    Генераторы - это тип итерации, подобный спискам или кортежам.
    В отличие от списков, они не допускают индексации произвольными индексами, но их все равно можно повторять с помощью циклов for.
    Они могут быть созданы с помощью функций и инструкции yield.
    Пример:

    def countdown():
        i=5
        while i > 0:
            yield i
            i -= 1

    for i in countdown():
        print(i, end = " ")

    >>5 4 3 2 1

    Оператор yield используется для определения генератора, заменяя возврат функции для предоставления результата ее вызывающей стороне без уничтожения локальных переменных.
    Из-за того, что они выдают по одному элементу за раз, генераторы не имеют ограничений памяти списков.
    На самом деле, они могут быть бесконечными!
    def infinite_sevens():
      while True:
        yield 7

      for i in infinite_sevens():
         print(i)

    Короче говоря, генераторы позволяют вам объявлять функцию, которая ведет себя как итератор, т.е. ее можно использовать в цикле for.
    Конечные генераторы можно преобразовать в списки, передав их в качестве аргументов функции list.

    def numbers(x):
    for i in range(x):
        if i % 2 == 0:
            yield i
    print(list(numbers(11)))
    >>[0, 2, 4, 6, 8, 10]

    Использование генераторов приводит к повышению производительности, что является результатом ленивой генерации значений (по требованию), что приводит к снижению использования памяти. Кроме того, нам не нужно ждать, пока все элементы будут сгенерированы, прежде чем мы начнем их использовать.

    def make_word():
      word = ""
      for ch in "spam":
        word +=ch
        yield word

    print(list(make_word()))
    >>['s', 'sp', 'spa', 'spam']


67.1 Decorators
    Декораторы предоставляют способ изменять функции, используя другие функции.
    Это идеально, когда вам нужно расширить функциональность функций, которые вы не хотите изменять.
    Пример:
        def decor(func):
      def wrap():
        print("============")
        func()
        print("============")
      return wrap

    def print_text():
      print("Hello world!")

    decorated = decor(print_text)
    decorated()

    Мы определили функцию с именем decor, которая имеет один параметр func. Внутри декора мы определили вложенную функцию с именем wrap. Функция wrap выведет строку, затем вызовет функцию func() и выведет другую строку. Функция decor возвращает функцию wrap в качестве своего результата.
    Мы могли бы сказать, что переменная decorated - это оформленная версия print_text - это print_text плюс что-то еще.
    На самом деле, если бы мы написали полезный декоратор, мы могли бы захотеть полностью заменить print_text на оформленную версию, чтобы мы всегда получали нашу версию print_text "плюс что-то".
    Это делается путем переназначения переменной, содержащей нашу функцию:

    Теперь print_text соответствует нашей оформленной версии.

68.1 Recursion
    Рекурсия - очень важное понятие в функциональном программировании.
    Фундаментальной частью рекурсии является самореференция - функции, вызывающие сами себя.
    Он используется для решения задач, которые могут быть разбиты на более простые подзадачи того же типа.

    Классическим примером функции, которая реализуется рекурсивно, является факториальная функция,
    которая находит произведение всех положительных целых чисел ниже указанного числа.
    Например, 5! (5 факториал) - это 5 * 4 * 3 * 2 * 1 (120). Чтобы реализовать это рекурсивно,
    обратите внимание, что 5! = 5 * 4!, 4! = 4 * 3!, 3! = 3 * 2!, и так далее. Как правило, n! = n * (n-1)!.
    Кроме того, 1! = 1. Это известно как базовый случай, поскольку его можно вычислить, не выполняя больше никаких факториалов.
    Ниже приведена рекурсивная реализация факторной функции.

    def factorial(x):
        if x == 1:
            return 1
        else:
            return x * factorial(x-1)

    print(factorial(5))
    Базовый случай действует как условие выхода рекурсии

    Рекурсивные функции могут быть бесконечными, точно так же,
    как бесконечные циклы while. Это часто происходит, когда вы
    забываете реализовать базовый вариант.
    Ниже приведена неправильная версия факторной функции. У него нет
    базового регистра, поэтому он выполняется до тех пор, пока у интерпретатора
    не закончится память и он не выйдет из строя.

    Рекурсия также может быть косвенной. Одна функция может вызывать вторую, которая
    вызывает первую, которая вызывает вторую и так далее. Это может произойти с любым
    количеством функций.

    def is_even(x):
    if x == 0:
        return True
    else:
        return is_odd(x-1)

    def is_odd(x):
        return not is_even(x)
    print(is_odd(1))
    print(is_even(0))
    >>True
    >>True

69.1 Sets

    Наборы - это структуры данных, аналогичные спискам или словарям.
    Они создаются с помощью фигурных скобок или функции set.
    Они обладают некоторыми общими функциональными возможностями со списками,
    такими как использование in для проверки того, содержат ли они определенный элемент.

    num_set = {1, 2, 3, 4, 5}
    word_set = set(["spam", "eggs", "sausage"])

    print(3 in num_set)
    print("spam" not in word_set)

    Наборы отличаются от списков несколькими способами, но имеют несколько общих операций со списком, таких как len.
    Они неупорядочены, что означает, что они не могут быть проиндексированы.
    Они не могут содержать повторяющиеся элементы.
    Благодаря тому, как они хранятся, быстрее проверить, является ли элемент частью набора, а не частью списка.
    Вместо использования append для добавления в набор используйте add.
    Метод remove удаляет определенный элемент из набора; pop удаляет произвольный элемент.

    nums = {1, 2, 1, 3, 1, 4, 5, 6}
    print(nums)
    nums.add(-7)
    nums.remove(3)
    print(nums)
    >>{1, 2, 3, 4, 5, 6}
    >>{1, 2, 4, 5, 6, -7}

    Наборы могут быть объединены с помощью математических операций.
    Оператор объединения | объединяет два набора, чтобы сформировать новый, содержащий элементы в любом из них.
    Оператор пересечения & получает элементы только в обоих.
    Оператор разницы - получает элементы в первом наборе, но не во втором.
    Оператор симметричной разности ^ получает элементы в любом наборе, но не в обоих.

    first = {1, 2, 3, 4, 5, 6}
    second = {4, 5, 6, 7, 8, 9}

    print(first | second)
    print(first & second)
    print(first - second)
    print(second - first)
    print(first ^ second)

    >>{1, 2, 3, 4, 5, 6, 7, 8, 9}
    >>{4, 5, 6}
    >>{1, 2, 3}
    >>{8, 9, 7}
    >>{1, 2, 3, 7, 8, 9}

    Как мы видели в предыдущих уроках, Python поддерживает следующие структуры данных: списки, словари, кортежи, наборы.

    Когда следует использовать словарь:
    - Когда вам нужна логическая связь между парой ключ:значение.
    - Когда вам нужен быстрый поиск ваших данных на основе пользовательского ключа.
    - Когда ваши данные постоянно изменяются. Помните, что словари изменяемы.

    Когда использовать другие типы:
    - Используйте списки, если у вас есть коллекция данных, которая не нуждается в произвольном доступе. Попробуйте выбирать списки, когда вам нужна простая, повторяющаяся коллекция, которая часто изменяется.
    - Используйте набор, если вам нужна уникальность для элементов.
    - Используйте кортежи, когда ваши данные не могут измениться.

    Часто кортеж используется в сочетании со словарем, например, кортеж может представлять ключ, поскольку он неизменяем.

70.1 IterTools
    Модуль itertools - это стандартная библиотека, которая содержит несколько функций, полезных в функциональном программировании.
    Один из типов функций, которые он создает, - это бесконечные итераторы.
    Функция count бесконечно отсчитывает от значения.
    Цикл функции бесконечно повторяется через итерируемый объект (например, список или строку).
    Функция repeat повторяет объект либо бесконечно, либо определенное количество раз.
    Пример:
    from itertools import count

for i in count(3):
    print(i, end=" ")
    if i >=11:
        break
    >>3 4 5 6 7 8 9 10 11

    В itertools есть много функций, которые работают с iterables аналогично отображению и фильтрации.
    Несколько примеров:
    takewhile - принимает элементы из итерируемого, в то время как функция-предикат остается истинной;
    цепочка - объединяет несколько итераций в одну длинную;
    накапливать - возвращает общее количество значений в итерации.

    from itertools import accumulate, takewhile

    nums = list(accumulate(range(8)))
    print(nums)
    print(list(takewhile(lambda x: x<= 6, nums)))
    >>[0, 1, 3, 6, 10, 15, 21, 28]
    >>[0, 1, 3, 6]

    В itertool также есть несколько комбинаторных функций, таких как произведение и перестановка.
    Они используются, когда вы хотите выполнить задачу со всеми возможными комбинациями некоторых элементов.
    Пример:

    from itertools import product, permutations

    letters = ("A", "B")
    print(list(product(letters, range(2))))
    print(list(permutations(letters)))

    >>[('A', 0), ('A', 1), ('B', 0), ('B', 1)]
    >>[('A', 'B'), ('B', 'A')]






