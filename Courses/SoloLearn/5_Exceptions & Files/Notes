Обработка исключений

Оператор try может содержать несколько различных блоков except для обработки различных исключений.
Несколько исключений также можно поместить в один блок except, используя круглые скобки, чтобы блок except обрабатывал их все.

try:
    variable = 10
    print(variable + "hello")
    print(variable / 2)
except ZeroDivisionError:
    print("Divided by zero")
except (ValueError, TypeError):
    print("Error occurred")


Finaly

Чтобы гарантировать выполнение некоторого кода независимо от того, какие ошибки возникают, вы можете использовать оператор finally. Оператор finally помещается в нижней части инструкции try/except.
Код внутри оператора finally всегда выполняется

try:
    print("Hello")
    print(1 / 0)
except ZeroDivisionError:
    print("Divided by zero")
finally:
    print("This code will run no matter what")

Код в операторе finally выполняется даже в том случае, если в одном из предыдущих блоков возникает неперехваченное исключение.

try:
    print(1)
    print(10 / 0)
except ZeroDivisionError:
    print(unknown_var)
finally:
    print("This is executed last")

    Создание исключений
    Вы можете создавать исключения с помощью инструкции raise.

    print(1)
    raise ValueError
    print(2)

    Вам необходимо указать тип возникшего исключения.

    name = "123"
    raise NameError("Invalid name!")

    Создание исключений
    В блоках except оператор raise может использоваться без аргументов для повторного вызова любого возникшего исключения.
    Например: xception поднят.
    try:
        num = 5 / 0
    except:
        print("An error occurred")
        raise

45.1 Assertions
    Утверждение - это проверка на вменяемость, которую вы можете включить или выключить, когда закончите тестирование программы.
    Выражение проверяется, и если результат оказывается ложным, возникает исключение.
    Утверждения выполняются с помощью оператора assert.

    print(1)
    assert 2 + 2 == 4
    print(2)
    assert 1 + 1 == 3
    print(3)

    Утверждение может принимать второй аргумент, который передается вызываемому AssertionError, если утверждение завершается неудачей.

    temp = -10
    assert (temp >= 0), "Colder than absolute zero!"

46.1 Opening Files

    Вы можете использовать Python для чтения и записи содержимого файлов.
    С текстовыми файлами проще всего манипулировать. Прежде чем файл можно будет редактировать, его необходимо открыть с помощью функции открыть.

    myfile = open("filename.txt")

    Аргументом функции open является путь к файлу. Если файл находится в текущем рабочем каталоге программы, вы можете указать только его имя.

    Вы можете указать режим, используемый для открытия файла, применив второй аргумент к функции open.
    Отправка "r" означает открытие в режиме чтения, который установлен по умолчанию.
    Отправка "w" означает режим записи для перезаписи содержимого файла.
    Отправка "a" означает режим добавления для добавления нового содержимого в конец файла.

    # write mode
    open("filename.txt", "w")

    # read mode
    open("filename.txt", "r")
    open("filename.txt")

    # binary write mode
    open("filename.txt", "wb")

    Вы можете использовать знак + в каждом из приведенных выше режимов, чтобы предоставить им дополнительный доступ к файлам. Например, r+ открывает файл как для чтения, так и для записи.

    После того, как файл был открыт и использован, вы должны закрыть его.
    Это делается с помощью метода close объекта file.

    file = open("filename.txt", "w")
    # do stuff to the file
    file.close()

    Чтобы прочитать только определенный объем файла, вы можете указать число в качестве аргумента функции чтения. Это определяет количество байтов, которые должны быть прочитаны.
    Вы можете выполнить больше вызовов для чтения одного и того же файлового объекта, чтобы читать больше файла байт за байтом. Без каких-либо аргументов функция read возвращает остальную часть файла.


    It is good practice to avoid wasting resources by making sure that files are always closed after they have been used. One way of doing this is to use try and finally
    Рекомендуется избегать напрасной траты ресурсов, следя за тем, чтобы файлы всегда закрывались после их использования. Один из способов сделать это - использовать try и finally

    try:
        f = open("filename.txt")
        print(f.read())
    finally:
        f.close()

    Альтернативный способ сделать это - использовать операторы with. Это создает временную переменную (часто называемую f), которая доступна только в блоке с отступом инструкции with.

    with open("filename.txt") as f:
        print(f.read())

