18.1 Booleans
    Another type in Python is the Boolean type. There are two Boolean values: True and False.
    They can be created by comparing values, for instance by using the equal operator ==.

    my_boolean = True
    print(my_boolean) //true
    print(2 == 3) //false
    print("hello" == "hello") //true

    Another comparison operator, the not equal operator (!=), evaluates to True if the items being compared aren't equal, and False if they are.
    print(1 != 1)               //false
    print("eleven" != "seven")  //true
    print(2 != 10)              //true

    Comparison operators are also called Relational operators.
    Python also has operators that determine whether one number (float or integer) is greater than or smaller than another. These operators are > and < respectively.

    Сравнение
    Операторы "больше" или "равно" и "меньше" или "равно" - это >= и <=.
    Они такие же, как строгие операторы больше, чем и меньше, чем, за исключением того, что они возвращают значение True при сравнении равных чисел.
    print(7 <= 8) //true
    print(9 >= 9.0) //true\

    Операторы Больше и меньше, чем также могут использоваться для лексикографического сравнения
    строк (алфавитный порядок слов основан на алфавитном порядке составляющих их букв).
    Например:
    print("Annie" > "Andy") //true
    Сравниваются первые два персонажа из "Энни" и "Энди" (А и А). Поскольку они равны, сравниваются вторые два символа.
     Поскольку они также равны, сравниваются два третьих символа (n и d).
    И поскольку n имеет большее значение алфавитного порядка, чем d, "Энни" больше, чем "Энди".

19.1 Конструкции IF
    Вы можете использовать инструкции if для запуска кода, если выполняется определенное условие.
    Если выражение принимает значение True, выполняются некоторые инструкции. В противном случае они не выполняются.
    Оператор if выглядит следующим образом:
    if expression:
       statements
    Python использует отступ (пробел в начале строки) для разграничения блоков кода.
    В зависимости от логики программы отступ может быть обязательным.
    Как вы можете видеть, операторы в if должны быть с отступом.

20.1 конструкции else
    Оператор if позволяет вам проверить условие и выполнить некоторые инструкции, если условие истинно.
    Оператор else может использоваться для выполнения некоторых инструкций, когда условие оператора if равно False.

    Как и в случае с операторами if, код внутри блока должен иметь отступ.
    x = 4
    if x == 5:
        print("Yes")
    else:
        print("No")

    В каждом блоке условий if может быть только один оператор else.
    Чтобы сделать несколько проверок, вы можете связать операторы if и else.
    Например, следующая программа проверяет и выводит значение переменной num в виде текста:
    num = 3
    if num == 1:
        print("One")
    else:
        if num == 2:
            print("Two")
        else:
            if num == 3:
                print("Three")  //Three
            else:
                print("Something else")

    Множественные операторы if/else делают код длинным и не очень читаемым.
    Оператор elif (сокращение от else if) - это ярлык для использования при объединении в цепочку операторов if и else, что сокращает код.

    Тот же пример из предыдущей части может быть переписан с использованием операторов elif:
    num = 3
    if num == 1:
        print("One")
    elif num == 2:
        print("Two")
    elif num == 3:
        print("Three")
    else:
        print("Something else")


21.1 Логика Boolean

    Булева логика используется для создания более сложных условий для операторов if, которые полагаются на более чем одно условие.
    Логическими операторами Python являются and, or и not.
    Оператор and принимает два аргумента и вычисляется как True тогда и только тогда, когда оба его аргумента истинны. В противном случае он оценивается как False.

    print(1 == 1 and 2 == 2)
    True
    print(1 == 1 and 2 == 3)
    False
    print(1 != 1 and 2 == 2)
    False
    print(2 < 1 and 3 > 6)
    False

    В отличие от других операторов, которые мы видели до сих пор, он не только принимает один аргумент, но и инвертирует его.
    Результат not True равен False, а not False переходит в True

    print(not 1 == 1) //False
    print(not 1 > 7)//True

    22.1 Несколько Операторов и условий
    Приоритет оператора - очень важная концепция в программировании.
    Это расширение математической идеи порядка операций (умножение выполняется перед сложением и т.д.), включающее другие операторы, например, в булевой логике.
    Приведенный ниже код показывает, что == имеет более высокий приоритет, чем или
    print(False == False or True)
    True
    print(False == (False or True))
    False
    print((False == False) or True)
    True

23.1 Списки(List)
Списки используются для хранения элементов.
Список создается с использованием квадратных скобок с разделяющими элементы запятыми.
words = ["Hello", "world", "!"]
В приведенном выше примере список слов содержит три строковых элемента.
К определенному элементу в списке можно получить доступ, используя его индекс в квадратных скобках.
Например:

words = ["Hello", "world", "!"]
print(words[0])
print(words[1])
print(words[2])

Иногда вам нужно создать пустой список и заполнить его позже во время работы программы.
Например, если вы создаете программу управления очередями, вначале очередь будет пустой,
а позже будет заполнена данными о пользователях.
empty_list = []
print(empty_list)

Как правило, список будет содержать элементы одного типа, но также возможно включить несколько разных типов.
Списки также могут быть вложены в другие списки.

number = 3
things = ["string", 0, [1, 2, number], 4.56]
print(things[1])
print(things[2])
print(things[2][2])

0
[1, 2, 3]
3

Вложенные списки можно использовать для представления 2D-сеток, таких как матрицы.
Например:
m = [
    [1,2,3],
    [4,5,6]
    ]

print(m[1][2])  //6

Некоторые типы, такие как строки, могут быть проиндексированы подобно спискам.
Индексирование строк ведет себя так, как если бы вы индексировали список, содержащий каждый символ в строке.
str = "Hello world!"
print(str[6]) //w


Чтобы проверить, отсутствует ли элемент в списке, вы можете использовать оператор not одним из следующих способов:
nums = [1, 2, 3]
print(not 4 in nums) //True
print(4 not in nums) //True
print(not 3 in nums) //False
print(3 not in nums) //False

25.1 Функции списка

Добавление элемента списака
nums = [1, 2, 3]
nums.append(4)
print(nums)

Подсчет количества элементов списка
nums = [1, 3, 5, 2, 4]
print(len(nums))

Метод insert аналогичен методу append,
за исключением того, что он позволяет
вставлять новый элемент в любую позицию списка, а не только в конец.

words = ["Python", "fun"]
index = 1
words.insert(index, "is")
print(words)

Метод index находит первое вхождение элемента списка и возвращает его индекс.
Если элемента нет в списке, он выдает ошибку ValueError.

max(list): Returns the list item with the maximum value
min(list): Returns the list item with minimum value
list.count(item): Returns a count of how many times an item occurs in a list
list.remove(item): Removes an object from a list
list.reverse(): Reverses items in a list.

26. Циклы While
    Цикл while используется для многократного повторения блока кода.
    Например, предположим, нам нужно обработать несколько пользовательских вводов, так что каждый раз, когда пользователь вводит что-то, должен выполняться один и тот же блок кода.
    Ниже приведен цикл while, содержащий переменную, которая подсчитывает от 1 до 5, и в этот момент цикл завершается.
    i = 1
    while i <=5:
    print(i)
    i = i + 1
    print("Finished!")

Вы можете использовать несколько операторов в цикле while.
Например, вы можете использовать оператор if для принятия решений.
Это может быть полезно, если вы создаете игру и вам нужно повторить ряд
действий игрока и добавить или удалить очки игрока.
Приведенный ниже код использует оператор if/else внутри цикла while для
разделения четных и нечетных чисел в диапазоне от 1 до 10:

x = 1
while x < 10:
    if x%2 == 0:
        print(str(x) + " is even")
    else:
        print(str(x) + " is odd")

    x += 1

BREAK!!!
Чтобы преждевременно завершить цикл while, можно использовать оператор break.
Например, мы можем прервать бесконечный цикл, если выполняется какое-то условие:
i = 0
while 1==1:
    print(i)
    i = i + 1
    if i >= 5:
        print("Breaking")
        break
print("Finished")

while True - это короткий и простой способ создать бесконечный цикл.

Пример использования break:
Бесконечный цикл while можно использовать для непрерывного приема пользовательского ввода.
Например, вы создаете калькулятор, и вам нужно взять цифры у пользователя, чтобы добавить и остановить, когда пользователь вводит "стоп".
В этом случае оператор break может быть использован для завершения бесконечного цикла, когда пользовательский ввод равен "stop".

Continue

Другой оператор, который можно использовать внутри циклов, - continue.
В отличие от break, continue возвращает к началу цикла, а не останавливает его.
По сути, оператор continue останавливает текущую итерацию и переходит к следующей.

Пример использования continue:
Система продажи авиабилетов должна рассчитать общую стоимость всех приобретенных билетов.
Билеты для детей в возрасте до 1 года предоставляются бесплатно.
Мы можем использовать цикл while для перебора списка пассажиров и вычисления общей стоимости их билетов.
Здесь оператор continue можно использовать для пропуска дочерних элементов.

i = 0
while i<5:
  i += 1
  if i==3:
    print("Skipping 3")
    continue
  print(i)

1
2
Skipping 3
4
5


27.1 for Loop
Цикл for используется для перебора заданной последовательности, такой как списки или строки.
Приведенный ниже код выводит каждый элемент в списке и добавляет восклицательный знак в конце:

words = ["hello", "world", "spam", "eggs"]
for word in words:
    print(word + "!")

hello!
world!
spam!
eggs!

В приведенном выше коде переменная word представляет соответствующий элемент списка на каждой итерации цикла.
Во время 1-й итерации слово равно "привет", а во время 2-й итерации оно равно "миру" и так далее.

Цикл for можно использовать для перебора строк.
str = "testing for loops"
count = 0
for x in str:
   if(x == 'o'):
    count += 1
print(count)

Приведенный выше код определяет переменную count,
выполняет итерацию по строке и вычисляет количество букв 'o' в ней.
Во время каждой итерации переменная x представляет текущую букву строки.
Переменная count увеличивается каждый раз, когда найдена буква 't', таким
образом, в конце цикла она представляет количество букв 't' в строке.

Как циклы for, так и while могут использоваться для многократного выполнения блока кода.

Обычно цикл for используется, когда количество итераций фиксировано.
Например, повторение по фиксированному списку товаров в списке покупок.

Цикл while используется в случаях, когда количество итераций неизвестно и зависит от некоторых
вычислений и условий в блоке кода цикла.
Например, завершение цикла, когда пользователь вводит определенный ввод в программу калькулятора.

Для достижения одних и тех же результатов можно использовать как циклы for, так и while, однако
цикл for имеет более чистый и короткий синтаксис, что делает его лучшим выбором в большинстве случаев.

28.1 Range
Функция range() возвращает последовательность чисел.
По умолчанию он начинается с 0, увеличивается на 1 и останавливается перед указанным числом.

Приведенный ниже код генерирует список, содержащий все целые числа, вплоть до 10.
numbers = list(range(10))
print(numbers)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
Чтобы вывести диапазон в виде списка, нам нужно явно преобразовать его в список, используя функцию list().

Если range вызывается с одним аргументом, он создает объект со значениями от 0 до этого аргумента.
Если он вызывается с двумя аргументами, он выдает значения от первого до второго.
Например:
numbers = list(range(3, 8))
print(numbers)

print(range(20) == range(0, 20))
[3, 4, 5, 6, 7]
True
Помните, что второй аргумент не включен в диапазон, поэтому диапазон (3, 8) не будет включать число 8.
диапазон может иметь третий аргумент,
который определяет интервал создаваемой последовательности, также называемый шагом.

numbers = list(range(5, 20, 2))
print(numbers)
[5, 7, 9, 11, 13, 15, 17, 19]

Мы также можем создать список убывающих чисел, используя отрицательное число в качестве
третьего аргумента, например list(диапазон(20, 5, -2)).
numbers = list(range(20, 5, -2))
print(numbers)
[20, 18, 16, 14, 12, 10, 8, 6]

Цикл for обычно используется для повторения некоторого кода определенное количество раз.
Это делается путем объединения циклов for с объектами диапазона.

for i in range(5):
    print("hello!")
hello!
hello!
hello!
hello!
hello!

Вам не нужно вызывать list для объекта range, когда он используется в цикле for,
потому что он не индексируется, поэтому список не требуется.
